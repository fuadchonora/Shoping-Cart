'use strict';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var createErrorMessage = function createErrorMessage(prefix, keyValue, message) {
  var key = prefix && prefix !== '' ? "".concat(prefix, ".").concat(keyValue) : keyValue;
  return {
    key: key,
    message: message
  };
};

var types = ['int', 'float', 'bool', 'string', 'array', 'enum', 'object', 'match'];

var createValidationResult = function createValidationResult(errors) {
  return {
    isValid: errors.length === 0,
    errors: errors
  };
};
/**
 * Validate schema definition
 *
 *  {
 *		type: pre-defined
 *    require: bool
 * 		enum: []
 * 		match: regex
 *		schema: object
 *  }
 */


var SchemaDefinitionValidator =
/*#__PURE__*/
function () {
  function SchemaDefinitionValidator() {
    _classCallCheck(this, SchemaDefinitionValidator);

    this.defintionQueue = [];
  }

  _createClass(SchemaDefinitionValidator, [{
    key: "_validate",
    value: function _validate(definition, propertyPrefix) {
      var _this = this;

      var errors = [];

      if (!definition.type || !types.includes(definition.type)) {
        errors.push(createErrorMessage(propertyPrefix, 'type', "'type' property is required and can only contains these values [".concat(types.join(), "]")));
      }

      if ('require' in definition && typeof definition.require !== 'boolean') {
        errors.push(createErrorMessage(propertyPrefix, 'require', '\'require\' property must be a boolean type'));
      }

      if (definition.type === 'enum') {
        if (!('enum' in definition)) {
          errors.push(createErrorMessage(propertyPrefix, 'enum', '\'enum\' property is required when type = \'enum\''));
        } else if (!Array.isArray(definition.enum)) {
          errors.push(createErrorMessage(propertyPrefix, 'enum', '\'enum\' property must be an array'));
        }
      }

      if (definition.type === 'match') {
        if (!('match' in definition)) {
          errors.push(createErrorMessage(propertyPrefix, 'match', '\'match\' property is required when type = \'match\''));
        } else if (typeof definition.match !== 'function' && !(definition.match instanceof RegExp)) {
          errors.push(createErrorMessage(propertyPrefix, 'match', '\'match\' property can only be function or RegExp'));
        }
      }

      if (definition.type === 'object') {
        if (!('schema' in definition)) {
          errors.push(createErrorMessage(propertyPrefix, 'schema', '\'schema\' property is required when type = \'object\''));
        } else if (_typeof(definition.schema) !== 'object') {
          errors.push(createErrorMessage(propertyPrefix, 'schema', '\'schema\' property must be an object'));
        } else {
          var keys = Object.keys(definition.schema);
          keys.forEach(function (key) {
            _this.defintionQueue.push({
              propertyPrefix: propertyPrefix ? "".concat(propertyPrefix, ".schema.").concat(key) : "schema.".concat(key),
              definition: definition.schema[key]
            });
          });
        }
      }

      return createValidationResult(errors);
    }
  }, {
    key: "isValid",
    value: function isValid(definition) {
      var propertyPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var errors = [];
      this.defintionQueue.push({
        definition: definition,
        propertyPrefix: propertyPrefix
      });

      while (this.defintionQueue.length > 0) {
        var nextDefinition = this.defintionQueue.shift();

        var result = this._validate(nextDefinition.definition, nextDefinition.propertyPrefix);

        if (!result.isValid) {
          errors = errors.concat(result.errors);
        }
      }

      return createValidationResult(errors);
    }
  }]);

  return SchemaDefinitionValidator;
}();

var schemaDefinitionValidator = new SchemaDefinitionValidator();

var ValueParser =
/*#__PURE__*/
function () {
  function ValueParser() {
    _classCallCheck(this, ValueParser);
  }

  _createClass(ValueParser, [{
    key: "_createReturnObj",
    value: function _createReturnObj(error, value) {
      var obj = {
        isValid: error === null
      };

      if (error) {
        if (Array.isArray(error)) {
          obj.errors = _toConsumableArray(error);
        } else {
          obj.errors = [error];
        }
      } else {
        obj.value = value;
      }

      return obj;
    }
  }, {
    key: "_parseInt",
    value: function _parseInt(fieldName, value) {
      if (typeof value === 'number' && Number.isInteger(value)) {
        return this._createReturnObj(null, value);
      } else if (typeof value === 'string' && /^\d+$/.test(value)) {
        var integer = Number.parseInt(value);
        return this._createReturnObj(null, integer);
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, 'not valid integer'));
    }
  }, {
    key: "_parseFloat",
    value: function _parseFloat(fieldName, value) {
      if (typeof value === 'number') {
        return this._createReturnObj(null, value);
      } else if (typeof value === 'string' && /^\d+[.]?\d*$/.test(value)) {
        var floatNumber = Number.parseFloat(value);
        return this._createReturnObj(null, floatNumber);
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, 'not valid float'));
    }
  }, {
    key: "_parseBoolean",
    value: function _parseBoolean(fieldName, value) {
      if (typeof value === 'boolean') {
        return this._createReturnObj(null, value);
      } else if (typeof value === 'string') {
        var strVal = value.toLowerCase();

        if (strVal === 'true') {
          return this._createReturnObj(null, true);
        } else if (strVal === 'false') {
          return this._createReturnObj(null, false);
        }
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, 'not valid boolean'));
    }
  }, {
    key: "_parseString",
    value: function _parseString(fieldName, value) {
      if (typeof value === 'string') {
        return this._createReturnObj(null, value);
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, 'not string type'));
    }
  }, {
    key: "_parseArray",
    value: function _parseArray(fieldName, value) {
      if (Array.isArray(value)) {
        return this._createReturnObj(null, value);
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, 'not Array type'));
    }
  }, {
    key: "_parseEnum",
    value: function _parseEnum(fieldName, value, definition) {
      if (definition.enum.includes(value)) {
        return this._createReturnObj(null, value);
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, "(".concat(value, ") is not one of pre-defined values [").concat(definition.enum, "]")));
    }
  }, {
    key: "_parseObject",
    value: function _parseObject(fieldName, value, definition) {
      var _this = this;

      if (_typeof(value) === 'object' && definition.schema) {
        var props = Object.keys(definition.schema);
        var obj = {};
        var errors = [];
        props.forEach(function (prop) {
          var parsedValue = _this.parse("".concat(fieldName, ".").concat(prop), value[prop], definition.schema[prop]);

          if (!parsedValue.isValid) {
            errors = errors.concat(parsedValue.errors);
          } else {
            obj[prop] = parsedValue.value;
          }
        });

        if (errors.length) {
          return this._createReturnObj(errors);
        }

        return this._createReturnObj(null, obj);
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, 'not Object type'));
    }
  }, {
    key: "_parseMatch",
    value: function _parseMatch(fieldName, value, definition) {
      var isValid = false;

      if (typeof definition.match === 'function') {
        isValid = definition.match(value);
      } else {
        isValid = definition.match.test(value);
      }

      if (isValid) {
        return this._createReturnObj(null, value);
      }

      return this._createReturnObj(createErrorMessage(null, fieldName, 'not valid based on the match property'));
    }
  }, {
    key: "parse",
    value: function parse(fieldName, value, definition) {
      // Set default require to true if it is not provided in the definition
      if (!('require' in definition)) {
        definition.require = true;
      } // value does not exist
      // Handle require and default


      if (value === null || value === undefined) {
        if (definition.require && definition.require === true && !('default' in definition)) {
          return this._createReturnObj(createErrorMessage(null, fieldName, 'is required, but value is null or undefined'));
        } else {
          return this._createReturnObj(null, 'default' in definition ? definition.default : null);
        }
      }

      switch (definition.type) {
        case 'int':
          return this._parseInt(fieldName, value);

        case 'float':
          return this._parseFloat(fieldName, value);

        case 'bool':
          return this._parseBoolean(fieldName, value);

        case 'string':
          return this._parseString(fieldName, value);

        case 'array':
          return this._parseArray(fieldName, value);

        case 'enum':
          return this._parseEnum(fieldName, value, definition);

        case 'object':
          return this._parseObject(fieldName, value, definition);

        case 'match':
          return this._parseMatch(fieldName, value, definition);

        default:
          return this._createReturnObj(createErrorMessage(null, 'type', "".concat(definition.type, " is not one of the valid definition types [").concat(types, "]")));
      }
    }
  }]);

  return ValueParser;
}();

var valueParser = new ValueParser();

var SchemaValidator =
/*#__PURE__*/
function () {
  function SchemaValidator() {
    _classCallCheck(this, SchemaValidator);
  }

  _createClass(SchemaValidator, [{
    key: "validate",
    value: function validate(object, schemaDefinition) {
      var keys = Object.keys(schemaDefinition);
      var definitionErrors = [];
      keys.forEach(function (key) {
        var result = schemaDefinitionValidator.isValid(schemaDefinition[key], key);

        if (!result.isValid) {
          definitionErrors = definitionErrors.concat(result.errors);
        }
      });

      if (definitionErrors.length) {
        return {
          isValid: false,
          error: {
            type: 'definition-error',
            data: definitionErrors
          }
        };
      }

      var schemaErrors = [];
      var returnObj = {};
      keys.forEach(function (key) {
        var result = valueParser.parse(key, object[key], schemaDefinition[key]);

        if (!result.isValid) {
          schemaErrors = schemaErrors.concat(result.errors);
        } else {
          returnObj[key] = result.value;
        }
      });

      if (schemaErrors.length) {
        return {
          isValid: false,
          error: {
            type: 'schema-error',
            data: schemaErrors
          }
        };
      }

      return {
        isValid: true,
        value: returnObj
      };
    }
  }]);

  return SchemaValidator;
}();

var schemaValidator = new SchemaValidator();

module.exports = schemaValidator;
